import { EventObject, StateMachine, State, InterpreterOptions, MachineOptions, StateConfig, Typestate } from 'xstate';
interface UseMachineOptions<TContext extends object, TEvent extends EventObject> {
    /**
     * If provided, will be merged with machine's `context`.
     */
    context: Partial<TContext>;
    /**
     * The state to rehydrate the machine to. The machine will
     * start at this state instead of its `initialState`.
     */
    state: StateConfig<TContext, TEvent>;
}
export declare function useMachine<TContext extends object, TEvent extends EventObject, TTypestate extends Typestate<TContext>>(machine: StateMachine<TContext, any, TEvent, TTypestate>, options?: Partial<InterpreterOptions> & Partial<UseMachineOptions<TContext, TEvent>> & Partial<MachineOptions<TContext, TEvent>>): {
    state: import("svelte/store").Readable<State<TContext, TEvent, any, TTypestate, import("xstate").TypegenDisabled>>;
    send: (event: import("xstate").SCXML.Event<TEvent> | import("xstate").SingleOrArray<import("xstate").Event<TEvent>>, payload?: import("xstate").EventData | undefined) => State<TContext, TEvent, any, TTypestate, import("xstate").TypegenDisabled>;
    service: import("xstate").Interpreter<TContext, any, TEvent, TTypestate, import("xstate").TypegenDisabled>;
};
export {};
//# sourceMappingURL=useMachine.d.ts.map